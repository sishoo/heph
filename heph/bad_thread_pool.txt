
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <sys/xattr.h>
#include <stdio.h>
#include <time.h>
#include <unistd.h>
#include <fcntl.h>
#include <immintrin.h>
#include <omp.h>
#include <pthread.h>
#include <emmintrin.h>
#include <stdatomic.h>
#include <signal.h>
#include <stdbool.h>

#define HEPH_THREAD_POOL_QUEUE_DEFAULT_CAP 25
#define HEPH_THREAD_POOL_ATOMIC_WAIT_MAX_SPIN 1000
#define HEPH_THREAD_POOL_ATOMIC_UINT32_CACHE_LINE_PADDING_NBYTES (HEPH_CPU_INFO_CACHE_LINE_SIZE_BYTES - sizeof(_Atomic(uint32_t)))

#define HFREE(ptr) free(ptr);
#define HCALLOC(a, b) calloc(a, b);
#define HEPH_CPU_INFO_NTHREADS 4
#define HEPH_CPU_INFO_CACHE_LINE_SIZE_BYTES 64

#define HEPH_ABORT(bruh) abort();

// #if HEPH_VALIDATE
// /* The values in this table are the thread indexes */
// static int mutex_usage_table[HEPH_CPU_INFO_NTHREADS] = {};

// #define MUTEX_LOCK(mutex_id, thread_id) mutex_usage_table[mutex_id] = thread_id;
// #define MUTEX_UNLOCK(mutex_id) mutex_usage_table[mutex_id] = 0;
// #define MUTEX_IS_OPERATING(mutex_id) (mutex_usage_table[mutex_id])
// #define MUTEX_CHECK_DEADLOCK(mutex_id, thread_id)              \
//         do                                                     \
//         {                                                      \
//                 if (MUTEX_IS_OPERATING(mutex_id) == thread_id) \
//                 {
//                         HEPH_ABORT("Mutex deadlock detected. Mutex " << mutex_id << " is double-locked on thread " << thread_id)
//                 }
// }
// while (0)
//         ;
// #else

/*
        TODO
        its definitly possible to make this without mutexes but whatever

        if you want work stealing then pass reference to entire tp
        also have to make checkout atomic. at that point maybe just use mutex



        the single mutex for queue works but there are problems:
                - cant submit while working
                - cant work while submitting




        maybe try making two structs
        and have a pointer to them be atomics





*/

typedef void *(*Routine)(void *);

typedef struct
{
        Routine fn;
        void *args;
} HephThreadPoolJob;

typedef struct
{
        _Atomic(uint32_t) njobs;
        char _njobs_padding[HEPH_THREAD_POOL_ATOMIC_UINT32_CACHE_LINE_PADDING_NBYTES];

        _Atomic(uint32_t) submit;
        char _submit_padding[HEPH_THREAD_POOL_ATOMIC_UINT32_CACHE_LINE_PADDING_NBYTES];

        _Atomic(uint32_t) checkout;
        char _checkout_padding[HEPH_THREAD_POOL_ATOMIC_UINT32_CACHE_LINE_PADDING_NBYTES];

        _Atomic(uint32_t) capacity;
        _Atomic(HephThreadPoolJob *) jobs;
} __attribute__((aligned(64))) HephThreadPoolQueue;

typedef struct
{
        bool kill;
        pthread_t handle;
        HephThreadPoolQueue queue;
} HephThreadPoolThread;

typedef struct
{
        bool accepting_work;
        uint32_t nthreads;
        HephThreadPoolThread *threads;
} HephThreadPool;

static bool heph_thread_pool_queue_checkout(HephThreadPoolQueue *const q, HephThreadPoolJob *const j)
{
        uint32_t njobs = atomic_load(&q->njobs);
        uint32_t capacity = atomic_load(&q->capacity);
        uint32_t checkout = atomic_load(&q->checkout);

        if (njobs == 0)
        {
                return false;
        }

        uint32_t i = checkout * !(checkout == capacity);
        j->fn = q->jobs[i].fn;
        j->args = q->jobs[i].args;
        atomic_exchange(&q->checkout, i + 1);
        atomic_fetch_sub(&q->njobs, 1);
        return true;
}

static void *heph_thread_pool_thread_routine(void *args)
{
        sigset_t sig_set;
        sigemptyset(&sig_set);
        sigaddset(&sig_set, SIGUSR1);
        pthread_sigmask(SIG_BLOCK, &sig_set, NULL);

        printf("HELPER THREAD HELLO!\n");
        HephThreadPoolThread *t = (HephThreadPoolThread *)args;
        while (!t->kill)
        {
                while (atomic_load(&t->queue.njobs) == 0)
                {
                        int sig;
                        sigwait(&sig_set, &sig);

                        if (sig == SIGUSR1)
                        {
                                break;
                        }
                }

                HephThreadPoolJob j = {};
                while (heph_thread_pool_queue_checkout(&t->queue, &j))
                {
                        j.fn(j.args);
                }
        }

        HephThreadPoolJob j = {};
        while (heph_thread_pool_queue_checkout(&t->queue, &j))
        {
                j.fn(j.args);
        }

        return NULL;
}

static void heph_thread_pool_queue_init(HephThreadPoolQueue *const q)
{
        memset(q, 0, sizeof(HephThreadPoolQueue));
        atomic_exchange(&q->capacity, HEPH_THREAD_POOL_QUEUE_DEFAULT_CAP);
        HephThreadPoolJob *jobs = (HephThreadPoolJob *)HCALLOC(HEPH_THREAD_POOL_QUEUE_DEFAULT_CAP, sizeof(HephThreadPoolJob));
        atomic_exchange(&q->jobs, jobs);
}

static void heph_thread_pool_queue_destroy(HephThreadPoolQueue *const q)
{
        HFREE(q->jobs);
}

static void heph_thread_pool_queue_reallocate(HephThreadPoolQueue *const q)
{
        printf("THIS SHOULDNT BE PRINTED\n");
        uint32_t capacity = atomic_load(&q->capacity);
        HephThreadPoolJob *jobs = atomic_load(&q->jobs);

        uint32_t new_capacity = capacity * 2;
        HephThreadPoolJob *new_memory = (HephThreadPoolJob *)HCALLOC(new_capacity, sizeof(HephThreadPoolJob));

        memcpy(new_memory, jobs, sizeof(HephThreadPoolJob) * capacity);

        atomic_exchange(&q->capacity, new_capacity);
        atomic_exchange(&q->checkout, 0);
        atomic_exchange(&q->submit, capacity);
        atomic_exchange(&q->jobs, new_memory);
        HFREE(jobs);
}

static uint32_t heph_thread_pool_queue_submit(HephThreadPoolQueue *const q, HephThreadPoolJob job)
{
        uint32_t i;
        if (atomic_load(&q->njobs) == (i = atomic_load(&q->capacity)))
        {
                heph_thread_pool_queue_reallocate(q);
                i = atomic_load(&q->capacity);
        }
        i *= !atomic_compare_exchange_strong(&q->submit, &i, 0);
        HephThreadPoolJob *jobs = atomic_load(&q->jobs);
        jobs[i].fn = job.fn;
        jobs[i].args = job.args;
        atomic_fetch_add(&q->submit);

/*
        old logic, might not be right with the atomic stuff
        because the value could have been atomically updated before doing the logic 
        then the logic would result in an incorrect value
        uint32_t njobs = atomic_load(&q->njobs);
        uint32_t capacity = atomic_load(&q->capacity);
        uint32_t submit = atomic_load(&q->submit);
        
        HephThreadPoolJob *jobs = atomic_load(&q->jobs);

        if (njobs == capacity)
        {
                heph_thread_pool_queue_reallocate(q);
        }

        uint32_t i = submit * !(submit == capacity);
        jobs[i].fn = job.fn;
        jobs[i].args = job.args;
        atomic_exchange(&q->submit, i + 1);
*/
}

void heph_thread_pool_init(HephThreadPool *const tp)
{
        memset(tp, 0, sizeof(HephThreadPool));

        tp->nthreads = HEPH_CPU_INFO_NTHREADS;

        const uint32_t threads_size = sizeof(pthread_t) * HEPH_CPU_INFO_NTHREADS;
        const uint32_t queues_size = sizeof(HephThreadPoolQueue) * HEPH_CPU_INFO_NTHREADS * 2;

        tp->threads = (HephThreadPoolThread *)HCALLOC(threads_size + queues_size, 1);

        for (uint32_t i = 0; i < HEPH_CPU_INFO_NTHREADS; i++)
        {
                heph_thread_pool_queue_init(&tp->threads[i].queue);

                if (pthread_create(&tp->threads[i].handle, NULL, heph_thread_pool_thread_routine, (void *)&tp->threads[i]) != 0)
                {
                        HEPH_ABORT("Unable to create thread for application thread pool.");
                }
        }

        tp->accepting_work = true;
}

void heph_thread_pool_destroy(HephThreadPool *const tp)
{
        tp->accepting_work = false;

        for (uint32_t i = 0; i < HEPH_CPU_INFO_NTHREADS; i++)
        {
                while (atomic_load(&tp->threads[i].queue.njobs))
                        ;
                heph_thread_pool_queue_destroy(&tp->threads[i].queue);
        }

        HFREE(tp->threads);
}

bool heph_thread_pool_submit(HephThreadPool *const tp, HephThreadPoolJob job)
{
        if (!tp->accepting_work)
        {
                return false;
        }

        uint32_t min_jobs = UINT32_MAX;
        uint32_t id = 0;
        for (uint32_t i = 0; i < HEPH_CPU_INFO_NTHREADS; i++)
        {
                uint32_t njobs = atomic_load(&tp->threads[i].queue.njobs);
                if (njobs == 0)
                {
                        id = i;
                        break;
                }
                else if (njobs < min_jobs)
                {
                        min_jobs = njobs;
                        id = i;
                }
        }

        if (!heph_thread_pool_queue_submit(&tp->threads[id].queue, job))
        {
                pthread_kill(tp->threads[id].handle, SIGUSR1);
        }

        return true;
}

void *bro(void *args)
{
        printf("HELLO BRO %u\n", (uint32_t)args);
        return NULL;
}

int main()
{       
        HephThreadPool tp = {};
        heph_thread_pool_init(&tp);

        sleep(1);

        clock_t time = clock();
        for (uint32_t i = 0; i < 100; i++)
        {

                HephThreadPoolJob j = {
                    .fn = bro,
                    .args = (void *)i};
                heph_thread_pool_submit(&tp, j);
        }
        time = clock() - time;

        heph_thread_pool_destroy(&tp);

        printf("TIME TO SUBMIT IS: %lf\n", (double) time / CLOCKS_PER_SEC);


        return 0;
}