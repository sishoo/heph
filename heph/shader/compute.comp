#version 450

#extension GL_GOOGLE_include_directive : require

#define USE_GLSL_TYPES
#include "heph_types/object.h"

#define FAR_NW 0
#define FAR_NE 1
#define FAR_SW 2
#define FAR_SE 3
#define NEAR_NW 4
#define NEAR_NE 5
#define NEAR_SW 6
#define NEAR_SE 7

layout (push_constant) uniform l0
{
        vec4 vertices[8];
} frustum;

struct AABB
{
        vec4 vertices[8];
};

struct Object
{
        mat4 model_mat;
        float bounding_radius;
        vec4 pos;

        uint index_start, nindices, vertex_start;
};

layout (binding = ) buffer l1
{
        uint nobjects, swap;
        Object objects[];
} object_buffer;

struct DrawCommand
{
        uint index_count;
        uint instance_count;
        uint first_index;
        uint vertex_offset;
        uint first_instance;
};

layout (binding = ) buffer l2
{
        atomic_uint ndraws;
        DrawCommand[] cmds;
} draw_buffer;

void main()
{
        if (objects.nobjects < gl_LocalInvocationId.x)
        {
                return;
        }

        uint id = gl_LocalInvocationId.x + object_buffer.nobjects * object_buffer.swap;

        Object object = object_buffer.objects[id];

        float frustum_depth = (frustum.vertices[FAR_NW] - frustum.vertices[NEAR_NW]).z;

        /* Check object intersection with frustum */
        vec4 transformed_pos = object.pos * object.mat;
        do 
        {
                /* Near/Far planes */
                vec3 far_center = 0.5 * ((frustum.vertices[FAR_NE] - frustum.vertices[FAR_NW]) + (frustum.vertices[FAR_SW] - frustum.vertices[FAR_NW]));
                vec3 c_to_o = object.pos - far_center;
                vec3 dist = dot(c_to_o, far_norm);
                if (dist < object.bounding_radius && dist < frustum_depth)
                {
                        break;
                }       

                





                return;
        } while (0);

        /* Update the draw buffer */ 
        uint draw_index = atomicCounterIncrement(draw_buffer.ndraws);
        draw_buffer.cmds[draw_index].index_count = object.nindices;
        draw_buffer.cmds[draw_index].instance_count = 1;
        draw_buffer.cmds[draw_index].first_index = object.index_start;
        draw_buffer.cmds[draw_index].vertex_offset = object.vertex_start;
        draw_buffer.cmds[draw_index].first_instance = id;
}